Parameters:
  RuleGroupName:
    Type: String
    Default: SpamHausIPList
  RuleGroupAction:
    Type: String
    Description: Used to define the action to take on a matching rule if found
    Default: drop
    AllowedValues:
      - alert
      - drop
  RuleGroupCapacity:
    Type: Number
    Default: 3000
    Description: Maximum number of rules this rule group can contain
    MinValue: 100
    MaxValue: 30000

Resources:
  StatefulRulegroup:
    Type: AWS::NetworkFirewall::RuleGroup
    Properties:
      RuleGroupName: !Sub "${AWS::StackName}-${RuleGroupName}-${RuleGroupAction}"
      Type: STATEFUL
      RuleGroup:
        RulesSource:
          RulesString: "#This will be updated via the Lambda function"
      Capacity: !Ref RuleGroupCapacity
      Description: >-
        Used to track a list of Emerging IP Threats from
        https://www.spamhaus.org/drop/drop.txt
      Tags:
        - Key: ProjectName
          Value: SpamHausIPFiltering
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: LambdaLogs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
        - PolicyName: NetworkFirewall
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - network-firewall:*
                Resource:
                  - !GetAtt StatefulRulegroup.RuleGroupArn
      Tags:
        - Key: ProjectName
          Value: SpamHausIPFiltering
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${LambdaFunction}"
      RetentionInDays: 14
    DeletionPolicy: Retain
  ScheduledRule:
    Type: AWS::Events::Rule
    Properties:
      Description: SpamHausDropDailyTrigger
      ScheduleExpression: "cron(0 0 * * ? *)"
      State: ENABLED
      Targets:
        - Arn:
            Fn::GetAtt:
              - "LambdaFunction"
              - "Arn"
          Id: TargetFunctionV1
  PermissionForEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref LambdaFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn:
        Fn::GetAtt:
          - ScheduledRule
          - Arn
  LambdaInvoke:
    Type: AWS::CloudFormation::CustomResource
    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt LambdaFunction.Arn
  LambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.12
      Handler: index.lambda_handler
      Timeout: 60
      Description: Used to fetch data from the Emerging Threats IP list and update the associated RuleGroup
      Tags:
        - Key: ProjectName
          Value: SpamHausIPFiltering
      Code:
        ZipFile: !Sub |
          import json
          import urllib.request
          import boto3
          from datetime import datetime
          import cfnresponse

          # Configuration - CloudFormation template values
          THREAT_INTEL_URL = "https://www.spamhaus.org/drop/drop.txt"  # SpamHaus DROP list
          RULE_GROUP_ARN = '${StatefulRulegroup.RuleGroupArn}'

          # SID ranges for Suricata rules - adjust these to avoid conflicts with other
          # rule sources. Each IP gets two rules: one for traffic FROM the IP, one for
          # traffic TO the IP
          SID_PREFIX_FROM = 10000  # SIDs for traffic FROM blocked IPs (10000-19999 range)
          SID_PREFIX_TO = 15000    # SIDs for traffic TO blocked IPs (15000-19999 range)

          # Rule message configuration
          RULE_MESSAGE_PREFIX = "SpamHaus blocked"  # Customize this for your organization

          # Rule capacity management
          RULE_GROUP_CAPACITY = ${RuleGroupCapacity}
          # Each IP creates 2 rules (see rule generation below): one for inbound traffic,
          # one for outbound traffic  
          MAX_RESULTS = RULE_GROUP_CAPACITY // 2  # e.g., 3000 รท 2 = 1500 IPs maximum

          # Initialize AWS clients
          networkfirewall = boto3.client('network-firewall')

          def fetch_ips():
              print("Fetching the list of IP addresses...")
              try:
                  with urllib.request.urlopen(THREAT_INTEL_URL) as response:
                      data = response.read().decode('utf-8')
                  
                  list_of_ips = [
                      line.split(" ;")[0] for line in data.splitlines() 
                      if line.strip() and line[0].isdigit()
                  ]
                  print(f"Fetched {len(list_of_ips)} IP addresses...")
                  return list_of_ips
              except urllib.error.URLError as e:
                  print(f"URL Error: {e.reason}")
              except urllib.error.HTTPError as e:
                  print(f"HTTP Error: {e.code} - {e.reason}")
              except Exception as e:
                  print(f"Unexpected error fetching IP addresses: {str(e)}")
              return []

          def update_rules(rule_group):
              params = rule_group.copy()
              params.pop("Capacity", None)
              params["RuleGroupName"] = params["RuleGroupResponse"]["RuleGroupName"]
              params["Type"] = params["RuleGroupResponse"]["Type"]
              # Remove keys that can't be updated
              params.pop("ResponseMetadata", None)
              params.pop("Capacity", None)
              params.pop("RuleGroupResponse", None)

              print("Updating rules...")
              try:
                  res = networkfirewall.update_rule_group(**params)
                  if res:
                      print(f"Updated '{params[\"RuleGroupName\"]}'.")
                      return True
                  else:
                      print(f"Error updating the rules for '{params[\"RuleGroupName\"]}'...")
                      return False
              except Exception as e:
                  print(f"Error updating rules: {str(e)}")
                  return False

          def generate_ip_rule(rule_type, ip, direction, message, sid):
              if direction == "from":
                  template = ('{rule_type} ip {ip} any -> any any '
                             '(msg:"{message} traffic from {ip}"; rev:1; sid:{sid};)')
              else:
                  template = ('{rule_type} ip any any -> {ip} any '
                             '(msg:"{message} traffic to {ip}"; rev:1; sid:{sid};)')
              
              return template.format(
                  rule_type=rule_type,
                  ip=ip,
                  message=message,
                  # Format SID as 4-digit number with leading zeros (e.g., 0001, 0123, 1000)
                  sid=f"{sid:04d}"
              )

          def create_rules(rule_group, rule_type):
              list_of_ips = fetch_ips()
              
              if not list_of_ips:
                  print("No IP addresses fetched. Aborting rule creation.")
                  return False

              # Limit results to stay within rule capacity
              original_count = len(list_of_ips)
              list_of_ips = list_of_ips[:MAX_RESULTS]
              was_truncated = original_count > MAX_RESULTS

              rules = []
              timestamp = datetime.utcnow().strftime("%a, %d %b %Y %H:%M:%S GMT")
              rules.append(f"# Last updated: {timestamp}")
              rules.append(f"# Processing {len(list_of_ips)} of {original_count} "
                          f"IP addresses (limit: {MAX_RESULTS})")
              if was_truncated:
                  rules.append(f"# WARNING: IP list truncated from {original_count} to "
                              f"{MAX_RESULTS} due to rule capacity limits")

              for index, ip in enumerate(list_of_ips):
                  rule_from = generate_ip_rule(
                      rule_type,
                      ip,
                      "from",
                      RULE_MESSAGE_PREFIX,
                      SID_PREFIX_FROM + index
                  )
                  rule_to = generate_ip_rule(
                      rule_type,
                      ip,
                      "to",
                      RULE_MESSAGE_PREFIX,
                      SID_PREFIX_TO + index
                  )
                  rules.append(rule_from)
                  rules.append(rule_to)

              rule_group["RuleGroup"]["RulesSource"]["RulesString"] = "\n".join(rules)
              return update_rules(rule_group)

          def lambda_handler(event, context):
              # Handle delete event
              if event["RequestType"] == "Delete":
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.SUCCESS,
                      {},
                      "Successfully processed Delete request"
                  )
                  return
              try:
                  params = {
                      "Type": "STATEFUL", 
                      "RuleGroupArn": RULE_GROUP_ARN
                  }
                  
                  print("Searching Rule Groups for 'SpamHausIPList'...")
                  res = networkfirewall.describe_rule_group(**params)

                  if "RuleGroupResponse" in res:
                      print("Found Rule Group...")
                      success = create_rules(res, "drop")
                      if success:
                          cfnresponse.send(
                              event,
                              context,
                              cfnresponse.SUCCESS,
                              {"Message": "Successfully updated Network Firewall rules with SpamHaus IP list"},
                              "Rule Group update successful"
                          )
                      else:
                          cfnresponse.send(
                              event,
                              context,
                              cfnresponse.FAILED,
                              {"Message": "Failed to update Network Firewall rules"},
                              "Rule Group update failed"
                          )
                  else:
                      print("ERROR: No matching Rule Group found...")
                      cfnresponse.send(
                          event,
                          context,
                          cfnresponse.FAILED,
                          {"Message": "No matching Rule Group found for the provided ARN"},
                          "Rule Group not found"
                      )
              except Exception as e:
                  print(f"An error occurred: {str(e)}")
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.FAILED,
                      {"Message": f"An error occurred: {str(e)}"},
                      "Lambda execution failed"
                  )

              return {
                  "statusCode": 200,
                  "body": json.dumps("Function executed successfully")
              }
